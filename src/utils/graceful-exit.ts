import { createTerminus } from "@godaddy/terminus";
import type { Logger, HealthCheckMap, IGracefulExit, IServer } from "../types";
export default class GracefulExit implements IGracefulExit {
  private isRegistered: boolean = false;
  private isShuttingDown = false;
  private readonly cleanupTasks: Set<() => Promise<void>> = new Set();
  constructor(private logger: Logger) {}
  /**
   * ‰∏∫HTTPÊúçÂä°Âô®ËÆæÁΩÆ‰ºòÈõÖÈÄÄÂá∫
   * @param server HTTPÊúçÂä°Âô®ÂÆû‰æã
   * @param logger Êó•ÂøóËÆ∞ÂΩïÂô®
   */
  register(
    server: IServer,
    options?: {
      timeout?: number;
      signals?: NodeJS.Signals[];
      healthCheck?: HealthCheckMap;
    }
  ): GracefulExit {
    if (this.isRegistered) return this;
    if (!server.listening) throw new Error("Server Not Listening");
    this.isRegistered = true;
    this.setupProcessHandlers();
    /**
     * ÂàõÂª∫‰ºòÈõÖÈÄÄÂá∫ÈÖçÁΩÆ
     * @param server - Ë¶ÅÈÖçÁΩÆÁöÑHTTPÊúçÂä°Âô®ÂÆû‰æã
     * @param options - ÈÖçÁΩÆÈÄâÈ°π {
     *   timeout: Ê∏ÖÁêÜË∂ÖÊó∂Êó∂Èó¥ÔºàÈªòËÆ§30000msÔºâ,
     *   signals: ÁõëÂê¨ÁöÑÁ≥ªÁªü‰ø°Âè∑ÔºàÈªòËÆ§SIGINT/SIGTERMÔºâ
     * }
     */
    createTerminus(server, {
      logger: this.logger.error,
      timeout: options?.timeout || 30000, // Ê∏ÖÁêÜË∂ÖÊó∂Êó∂Èó¥ÔºàÈªòËÆ§30ÁßíÔºâ
      signals: options?.signals || ["SIGINT", "SIGTERM"], // ÁõëÂê¨ÁöÑÁ≥ªÁªü‰ø°Âè∑
      healthChecks: options?.healthCheck || {}, // ‰ΩøÁî®‰πãÂâçÊ∑ªÂä†ÁöÑÂÅ•Â∫∑Ê£ÄÊü•Á´ØÁÇπ
      onSignal: async () =>
        await this.handleSignal("üö¶ Received termination signal"),
    });
    return this;
  }
  /**
   * Ê∑ªÂä†ËµÑÊ∫êÂÖ≥Èó≠‰ªªÂä°
   * @param task ËøîÂõûPromiseÁöÑËµÑÊ∫êÂÖ≥Èó≠ÂáΩÊï∞
   */
  addCleanupTask(...tasks: (() => Promise<void>)[]) {
    tasks.forEach((task) => this.cleanupTasks.add(task));
  }

  /**
   * ÊâßË°åÊâÄÊúâÊ∏ÖÁêÜ‰ªªÂä°
   */
  private async cleanup() {
    if (this.cleanupTasks.size === 0) return;
    await Promise.all([...this.cleanupTasks].map((task) => task()));
    this.cleanupTasks.clear();
    this.logger.info("‚úÖ All resources closed");
  }

  /**
   * ËÆæÁΩÆËøõÁ®ã‰ø°Âè∑Â§ÑÁêÜÂô®
   */
  private setupProcessHandlers() {
    // Êú™ÊçïËé∑ÂºÇÂ∏∏
    process.on("uncaughtException", (err: Error) =>
      this.handleSignal("‚ùå Uncaught Exception:", err)
    );
    // Êú™Â§ÑÁêÜÁöÑPromiseÊãíÁªù
    process.on("unhandledRejection", (err: Error) =>
      this.handleSignal("‚ö†Ô∏è Unhandled Rejection:", err)
    );
  }
  private async handleSignal(msg: string, err?: Error) {
    if (this.isShuttingDown) return;
    this.isShuttingDown = true;
    if (err) this.logger.error(msg, err);
    else this.logger.info(msg);
    await this.cleanup();
  }
}
